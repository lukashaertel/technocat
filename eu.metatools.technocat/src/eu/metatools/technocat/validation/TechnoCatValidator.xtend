/*
 * generated by Xtext
 */
package eu.metatools.technocat.validation

import eu.metatools.technocat.technoCat.RD
import eu.metatools.technocat.technoCat.TechnoCatPackage
import org.eclipse.xtext.validation.Check

import static extension eu.metatools.technocat.reasoning.TechnoCatExpansions.*
import static extension eu.metatools.technocat.reasoning.TechnoCatExtensions.*
import static extension eu.metatools.technocat.reasoning.TechnoCatRelations.*
import static extension eu.metatools.technocat.reasoning.TechnoCatScopes.*
import static extension eu.metatools.technocat.util.TechnoCatStrings.*
import static extension eu.metatools.technocat.util.TechnoCatEcore.*
import eu.metatools.technocat.technoCat.ModelElement
import eu.metatools.technocat.technoCat.DefinitionElement
import eu.metatools.technocat.technoCat.ETD
import eu.metatools.technocat.technoCat.ED
import javax.naming.Name
import eu.metatools.technocat.technoCat.RTD
import eu.metatools.technocat.technoCat.EDItem

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TechnoCatValidator extends AbstractTechnoCatValidator {
	public static val NO_APPLICABLE_RELATION = "noApplicableRelation"
	public static val NAME_ALREADY_USED = "nameAlreadyUsed"

	@Check
	def checkValidRelation(RD it) {
		guard(left != null)
		guard(left.type != null)

		guard(relation != null)

		guard(right != null)
		guard(right.type != null)

		if (applicableOverloads.empty) {

			// Get entity type hierachy for the left type
			val hleft = left.type.iexpand[effectiveBases].map[name]

			// Get relation type hierachy
			val hrelation = relation.iexpand[effectiveBases].map[name]

			// Get entity type hierachy for the right type
			val hright = right.type.iexpand[effectiveBases].map[name]

			error(
				'''No applicable relation for «hleft.representation» «hrelation.representation» «hright.representation»''',
				TechnoCatPackage.Literals.RD__RELATION, NO_APPLICABLE_RELATION)
		}
	}

	@Check
	def checkUniqueEntityTypes(ETD x) {
		if (x.technologyCatalog.effectiveETDs.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.DEFINITION_ELEMENT__NAME, NAME_ALREADY_USED)
		}
	}

	@Check
	def checkUniqueRelationTypes(RTD x) {
		if (x.technologyCatalog.effectiveRTDs.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.DEFINITION_ELEMENT__NAME, NAME_ALREADY_USED)
		}
	}

	@Check
	def checkUniqueRelationTypes(EDItem x) {
		if (x.technologyCatalog.effectiveEDs.map[items].flatten.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.ED_ITEM__NAME, NAME_ALREADY_USED)
		}
	}
}
