/*
 * generated by Xtext
 */
package eu.metatools.technocat.validation

import eu.metatools.technocat.technoCat.EDItem
import eu.metatools.technocat.technoCat.ETD
import eu.metatools.technocat.technoCat.RD
import eu.metatools.technocat.technoCat.RTD
import eu.metatools.technocat.technoCat.TechnoCatPackage
import eu.metatools.technocat.technoCat.TechnologyCatalog
import org.eclipse.xtext.validation.Check

import static extension eu.metatools.technocat.reasoning.TechnoCatMetrics.*
import static extension eu.metatools.technocat.reasoning.TechnoCatExpansions.*
import static extension eu.metatools.technocat.reasoning.TechnoCatExtensions.*
import static extension eu.metatools.technocat.reasoning.TechnoCatRelations.*
import static extension eu.metatools.technocat.reasoning.TechnoCatScopes.*
import static extension eu.metatools.technocat.util.TechnoCatStrings.*
import eu.metatools.technocat.technoCat.ED

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TechnoCatValidator extends AbstractTechnoCatValidator {
	public static val NO_APPLICABLE_RELATION = "noApplicableRelation"
	public static val NAME_ALREADY_USED = "nameAlreadyUsed"

	@Check
	def metricate(TechnologyCatalog t) {
		info('''Rels : «t.relations.filter[applicableOverloads.empty].size»/«t.relations.size»''', null)
		info('''SOV: «t.SOV»''', null)
		info('''ENR: «t.ENR»''', null)
		info('''TIP: «t.TIP»''', null)
		info('''EOG: «t.EOG»''', null)

		val nocs = t.entityTypes.map[e|t.NOC(e)]
		val dits = t.entityTypes.map[e|t.NOC(e)]

		val cids = t.entities.map[e|t.CID(e)]
		val cods = t.entities.map[e|t.COD(e)]

		val nocsMin = nocs.reduce[a, b|Math.min(a, b)]
		val nocsAvg = nocs.map[x|x as double].reduce[a, b|a / 2.0 + b / 2.0]
		val nocsMax = nocs.reduce[a, b|Math.max(a, b)]

		info('''NOC min: «nocsMin», avg: «nocsAvg», max: «nocsMax»''', null)

		val ditsMin = dits.reduce[a, b|Math.min(a, b)]
		val ditsAvg = dits.map[x|x as double].reduce[a, b|a / 2.0 + b / 2.0]
		val ditsMax = dits.reduce[a, b|Math.max(a, b)]

		info('''DIT min: «ditsMin», avg: «ditsAvg», max: «ditsMax»''', null)

		val cidsMin = cids.reduce[a, b|Math.min(a, b)]
		val cidsAvg = cids.map[x|x as double].reduce[a, b|a / 2.0 + b / 2.0]
		val cidsMax = cids.reduce[a, b|Math.max(a, b)]

		info('''CID min: «cidsMin», avg: «cidsAvg», max: «cidsMax»''', null)

		val codsMin = cods.reduce[a, b|Math.min(a, b)]
		val codsAvg = cods.map[x|x as double].reduce[a, b|a / 2.0 + b / 2.0]
		val codsMax = cods.reduce[a, b|Math.max(a, b)]

		info('''COD min: «codsMin», avg: «codsAvg», max: «codsMax»''', null)
	}

	@Check
	def metricate(ETD e) {
		info('''NOC: «e.technologyCatalog.NOC(e)»''', null)
		info('''DIT: «e.technologyCatalog.DIT(e)»''', null)
	}

	@Check
	def metricate(ED e) {
		info('''CID: «e.technologyCatalog.CID(e)»''', null)
		info('''COD: «e.technologyCatalog.COD(e)»''', null)
	}

	@Check
	def check(RD it) {
		guard(left != null)
		guard(left.type != null)

		guard(relation != null)

		guard(right != null)
		guard(right.type != null)

		if (applicableOverloads.empty) {

			// Get entity type hierachy for the left type
			val hleft = left.type.iexpand[effectiveBases].map[name]

			// Get relation type hierachy
			val hrelation = relation.iexpand[effectiveBases].map[name]

			// Get entity type hierachy for the right type
			val hright = right.type.iexpand[effectiveBases].map[name]

			error(
				'''No applicable relation for «hleft.representation» «hrelation.representation» «hright.representation»''',
				TechnoCatPackage.Literals.RD__RELATION, NO_APPLICABLE_RELATION)

			return false
		}

		return true
	}

	@Check
	def check(ETD x) {
		if (x.technologyCatalog.effectiveETDs.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.DEFINITION_ELEMENT__NAME, NAME_ALREADY_USED)

			return false
		}

		return true
	}

	@Check
	def check(RTD x) {
		if (x.technologyCatalog.effectiveRTDs.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.DEFINITION_ELEMENT__NAME, NAME_ALREADY_USED)

			return false
		}

		return true
	}

	@Check
	def check(EDItem x) {
		if (x.technologyCatalog.effectiveEDs.map[items].flatten.exists[y|x != y && x.name == y.name]) {
			error('''Multiple defintions''', TechnoCatPackage.Literals.ED_ITEM__NAME, NAME_ALREADY_USED)
			return false
		}
		return true
	}
}
